## Boundary testing
The boundary area between partitions is often buggy. When the boundary is exercised, the system should behave as expected. This is called **boundary testing**.


### CORRECT - Boundary conditions
The CORRECT acronym is a mnemonic for conditions under which the code's behaviour might differ from expected. These are also called **boundary conditions**.
* **C**onformance: Does the value conform to an expected format?
 * **O**rdering: Is the set of data ordered or unordered as appropriate?
 * **R**ange: Is the value within reasonable minimum and maximum values?
* **R**eference: Does the code reference anything external that isn't under the direct control of the code itself?
     * What does the code reference outside its scope?
	 *  What external dependencies has the code?
     * Does the code depend on an object being in a certain state?
     * Are there any conditions that must be met?
 * **E**xistence: Does the value exist?
 * **C**ardinality: Are there exactly enough values?
	 * A lot of mistakes are made when creating loops. The loop for example executes one time too many or one time too little. This is called an off-by-one error.
     * This is why there should be tests that execute the loop zero, one and many times.
 * **T**ime: Is everything happening in order? 
     * What happens if methods are invoked out of order?
     * What happens if there is a timeout?
     *  Does the date or time influence the program?

It might happen that the opposite of the applicable conditions is true. For example, what happens if an input does not *conform* to the expected format? These situations should be tested.

[comment]: <> (Chapter 5 Langr, J., Hunt, A., & Thomas, D. (2015). Pragmatic unit testing in Java 8 with JUnit. Pragmatic Bookshelf.)
</br> 
</br>
**exercise**
Zip codes in country X are always composed of 4 numbers + 2 letters, e.g., 2628CD. Numbers are in the range [1000, 4000].
Letters are in the range [C, M]. 

Consider a program that receives two inputs: an integer (for the 4 numbers) and a string (for the 2 letters), and returns true (valid zip code) or false (invalid zip code). A tester comes up with the following partitions:

 * $[0,999]$
 * $[1000,4000]$
 * $[2001, 3500]$
 * $[3500, 3999]$
 * $[4001, 9999]$
 * $[A-C]$
 * $[C-M]$
 * $[N-Z]$

Which of the partitions above are **valid**?

(Note that "$[$" and "$]$" indicate that numbers in the boundaries are included in the domain. $[a,b]$ $\rightarrow$ all numbers between a and b, including a and b.)

**answer**
1, 2, 5, 7, 8

### On and off points
An **in point** makes the condition true.
An **out point** makes the condition false.
An **on point** is exactly on the boundary.
An **off point** is as close to the boundary as possible. If the on point is an in point, the off point is an out point and vice versa.

**example**
score $\geq$ 100
An in point is for example 200.
An out point is for example 50.
The on point is 100.
The off point is 99, if score is an integer.


**exercise**
A game has the following condition: *numberOfPoints $\leq$ 570*. What are the correct in, and out and on, and off points for numberOfPoints?

**answer**
on point = 570, off point = 571, in point = 50, out point = 1000

### Open or closed boundaries}
A boundary can be open or closed. An open boundary means that one side is not defined. This can be more difficult to test because one can't be entirely sure what point to pick for the off point.\newline

**example**
x $>$ 0 is an open boundary.
y $\leq$ 10 is a closed boundary.
</br>
</br>
To deal with an open boundary a **simplified domain testing strategy** could be used:
 1.  If there are multiple boundaries, they should be handled independently.
 2. Pick an off and on point for each boundary.
 3. Use varying in points for the other boundaries that are not currently being tested.

A domain matrix can be a helpful tool.


**example** domain matrix
Boundary conditions for "x $>$ 0 \&\& x $\leq$ 10 \&\& y $\geq$ 10"

| Variable | Condition | Type | t1   | t2   | t3    | t4     | t5  | t6  |
|----------|-----------|------|------|------|-------|--------|-----|-----|
| x        |  $>$0     | on   | 0    |      |       |        |     |     |
|          |           | off  |      | 1    |       |        |     |     |
|          | $\leq$    | on   |      |      | 10    |        |     |     |
|          |           | off  |      |      |       | 11     |     |     |
|          | typical   | in   |      |      |       |        | 4   | 6   |
| y        | $\geq$ 10 | on   |      |      |       |        | 1.0 |     |
|          |           | off  |      |      |       |        |     | 9.0 |
|          | typical   | in   | 10.0 | 16.0 | 109.3 | 2390.2 |     |     |

**exercise**
A game has the following condition:
*(numberOfPoints $\leq$ 570 and numberOfLives > 10) or energyLevel == 5*.
Perform boundary analysis (by building a domain matrix). How many test cases are derived after the analysis? 

**answer**
Seven. NumberOfPoints and NumberOfLives have one off point and one on point each, which adds to four tests. Energy level has two off points and one on point, since it's an equality. This adds three more tests, making the total seven.

### Parameterised tests
**Parameterised tests** allow a developer to run the same tests using different inputs and expected outputs. This makes tests more easily maintainable. Parameterised tests make use of an ArgumentSource @CsvSourse, which stands for **c**omma-**s**eperated **v**alues.


**example** parameterised test
<pre><code>@ParameterizedTest
@CsvSource({"Input, seperated", "by, comma"}
public void methodTo(int be, int tested) {
//  code goes here.
}
</code></pre>

